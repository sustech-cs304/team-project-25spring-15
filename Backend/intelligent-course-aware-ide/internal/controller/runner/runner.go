// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package runner

import (
	"context"
	"fmt"
	v1 "intelligent-course-aware-ide/api/runner/v1"
	"os"
	"os/exec"
	"strings"

	"github.com/gogf/gf/v2/errors/gcode"
	"github.com/gogf/gf/v2/errors/gerror"
)

const TargetDockerName string = "CS304"
const TargetPythonDockerName string = TargetDockerName
const TargetCDockerName string = TargetDockerName
const TmpFileName string = "temp_script"
const PathForHost string = "C:\\Users\\sunyy\\Desktop\\SUSTECH\\Software_Engineering\\code\\Project\\team-project-25spring-15\\tmp\\"
const PathForDocker string = "/usr/Document/"

func CheckWhetherContainerIsRunning(targetDockerName string) string {
	var cmd *exec.Cmd = exec.Command("docker", "ps", "--filter", fmt.Sprintf("name=%s", targetDockerName), "--format", "{{.Names}}")
	output, err := cmd.Output()
	if err != nil {
		print(err)
		return fmt.Sprintf("Error checking Docker container: %v", err.Error())
	}

	var dockerNames []string = strings.Split(strings.TrimSpace(string(output)), "\n")
	var hasStarted bool = false
	for _, dockerName := range dockerNames {
		if targetDockerName == dockerName {
			hasStarted = true
			break
		}
	}

	if !hasStarted {
		// If there is not such a container, create and start a new one
		cmd = exec.Command("docker", "run", "-d", "--name", targetDockerName, "-v", "/tmp:/tmp", "python:3.8-slim")
		_, err = cmd.Output()
	} else {
		// If the container is already exist, just start it
		cmd = exec.Command("docker", "start", targetDockerName)
		_, err = cmd.Output()
	}

	if err != nil {
		print(err)
		return fmt.Sprintf("Error starting Docker container: %v", err.Error())
	}

	return "success"
}

func CCodeRunner(ctx context.Context, codeInfo *v1.RunnerReq) (pathForCDocker string, pathForExecutableFile string, err error) {
	var name string = codeInfo.Name
	var checkResult string = CheckWhetherContainerIsRunning(TargetCDockerName)
	if checkResult != "success" {
		return "", "", gerror.NewCode(gcode.CodeInternalError, checkResult)
	}

	var pathForCHost string = PathForHost + name + ".cpp"
	if err := os.WriteFile(pathForCHost, []byte(codeInfo.Code), 0644); err != nil {
		return "", "", gerror.Wrap(err, "Fail to write")
	}

	pathForCDocker = PathForDocker + name + ".cpp"
	pathForExecutableFile = PathForDocker + name

	return pathForCDocker, pathForExecutableFile, err
}

func RunCCode(ctx context.Context, codeInfo *v1.RunnerReq, pathForCDocker string, pathForExecutableFile string) (codeFeedback *v1.RunnerRes, err error) {
	var cmd *exec.Cmd
	var compileErr string
	var stdout, stderr strings.Builder

	cmdStr1 := "g++ " + pathForCDocker + " -o " + pathForExecutableFile
	cmd = exec.CommandContext(ctx, "docker", "exec", TargetCDockerName, cmdStr1)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	cmd.Run()

	compileErr = stderr.String()
	if compileErr != "" {
		codeFeedback = &v1.RunnerRes{
			Result:   stdout.String(),
			Error:    compileErr,
			FilePath: "",
		}

		return codeFeedback, err
	}

	stdout.Reset()
	stderr.Reset()

	cmdStr2 := "pathForExecutableFile"
	if codeInfo.Args != nil {
		for _, arg := range codeInfo.Args {
			cmdStr2 += " " + arg
		}
	} else {
		if codeInfo.InputPath != "" {
			cmdStr2 += " < " + codeInfo.InputPath
		}
		if codeInfo.OutputPath != "" {
			cmdStr2 += " > " + codeInfo.OutputPath
		}
	}

	var cmdContext []string = []string{
		"exec", "-it", TargetCDockerName, "bash", "-c", cmdStr2,
	}

	cmd = exec.CommandContext(ctx, "docker", cmdContext...)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	cmd.Run()
	codeFeedback = &v1.RunnerRes{
		Result:   stdout.String(),
		Error:    stderr.String(),
		FilePath: "",
	}
	return codeFeedback, err
}

func PythonCodeRunner(ctx context.Context, codeInfo *v1.RunnerReq) (pathForPythonDocker string, err error) {
	var name string = codeInfo.Name
	// Check if the Docker container is running
	var checkResult string = CheckWhetherContainerIsRunning(TargetPythonDockerName)
	if checkResult != "success" {
		return "", gerror.NewCode(gcode.CodeDbOperationError, checkResult)
	}

	// Create a temporary file to store the Python code
	// Write the code into the file
	var pathForPythonHost string = PathForHost + name + ".py"
	if err := os.WriteFile(pathForPythonHost, []byte(codeInfo.Code), 0644); err != nil {
		return "", gerror.Wrap(err, "Fail to write")
	}

	// Here we use new path to replace the ordinary path
	// But we have not implement file upload so we will implement it later
	pathForPythonDocker = PathForDocker + name + ".py"

	return pathForPythonDocker, err
}

func RunPythonCode(ctx context.Context, codeInfo *v1.RunnerReq, pathForPythonDocker string) (codeFeedback *v1.RunnerRes, err error) {
	// Here we use new path to replace the ordinary path
	// But we have not implement file upload so we will implement it later
	cmdStr := "python " + pathForPythonDocker
	if codeInfo.Args != nil {
		for _, arg := range codeInfo.Args {
			cmdStr += " " + arg
		}
	} else {
		if codeInfo.InputPath != "" {
			cmdStr += " < " + codeInfo.InputPath
		}
		if codeInfo.OutputPath != "" {
			cmdStr += " > " + codeInfo.OutputPath
		}
	}
	var cmdContext []string = []string{
		"exec", TargetPythonDockerName, "bash", "-c", cmdStr,
	}

	var cmd *exec.Cmd = exec.CommandContext(ctx, "docker", cmdContext...)

	var stdout, stderr strings.Builder
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	cmd.Run()
	codeFeedback = &v1.RunnerRes{
		Result:   stdout.String(),
		Error:    stderr.String(),
		FilePath: "",
	}

	return codeFeedback, err
}
